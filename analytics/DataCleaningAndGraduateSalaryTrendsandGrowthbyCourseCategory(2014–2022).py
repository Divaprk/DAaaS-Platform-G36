# -*- coding: utf-8 -*-
"""AnalyticsForCloudProj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_W7TIPgWUzEow4NwwJC1JpLE_hgw0EOt

#Step 1: Data Cleaning

Importing the relavent datasets:

GraduateEmploymentSurveyNTUNUSSITSMUSUSSSUTD.csv (ges)

IntakeEnrolmentandGraduatesofUniversitiesbyCourse.csv (ieg)
"""

import pandas as pd

ges = pd.read_csv("../data/GraduateEmploymentSurveyNTUNUSSITSMUSUSSSUTD.csv")

ieg = pd.read_csv("../data/IntakeEnrolmentandGraduatesofUniversitiesbyCourse.csv")

"""Taking note of the data types and seeing which ones need conversion"""

ges.dtypes

"""employment_rate_overall, employment_rate_ft_perm, basic_monthly_mean, basic_monthly_median, gross_monthly_mean, gross_monthly_median, gross_mthly_25_percentile and gross_mthly_75_percentile are all objects, need to change them into int"""

numeric_cols = [
    "employment_rate_overall",
    "employment_rate_ft_perm",
    "basic_monthly_mean",
    "basic_monthly_median",
    "gross_monthly_mean",
    "gross_monthly_median",
    "gross_mthly_25_percentile",
    "gross_mthly_75_percentile"
]

for col in numeric_cols:
    ges[col] = pd.to_numeric(ges[col], errors="coerce")

"""Now double checking"""

ges.dtypes

"""Checking for any N.A. values and dropping them"""

ges.isna().sum()

ges = ges.dropna()

ges.isna().sum()

"""For convenience, rename degree to course"""

ges = ges.rename(columns={"degree": "course"})
ges.info()

"""# Categorization of degrees

Upon listing schools, some of them were quite vauge:
  
'Trinity College Dublin / Singapore Institute of Technology-Trinity College Dublin'

'University of Liverpool'

'YST Conservatory Of Music'

'Yale-NUS College'

'Multi-Disciplinary Programmes'

this makes it hard to tell what they teach, so we cannot fully rely on these for degree categorization
"""

ges["school"].unique()

"""We can map all courses in ges to the courses in ieg (IntakeEnrolmentandGraduatesofUniversitiesbyCourse.csv)"""

ges["course"].unique()[:20]

ieg["course"].unique()

"""Firstly, we need to properly format the course names in ges as much as possible to standardize them via regex"""

ges["course"] = ges["course"].str.lower()

ges["course"] = ges["course"].str.replace(
    r"\(\s*\d+\s*[-‚Äì]?\s*(yr|year)[s]?\s*(direct\s*)?(honours\s*)?programme\s*\)",
    " ",
    regex=True
)

removables = [
    r"bachelor of ",
    r"double degree in ",
    r"\(hons\)",
    r"honours",
    r"cum laude and above",
    r"\*",
    r"#",
    r"\^",
    r"\n"
]

for pat in removables:
    ges["course"] = ges["course"].str.replace(
        pat, " ", regex=True
    )

ges["course"] = (
    ges["course"]
    .str.replace("&", "and", regex=False)
    .str.replace(r"\(", " (", regex=True)
    .str.replace(r"\)", ") ", regex=True)
    .str.replace(r"\(\s*\)", "", regex=True)
    .str.replace(r"\s+", " ", regex=True)
    .str.strip()
)

ges["course"] = ges["course"].str.replace(r"[']", "", regex=True)

ges["course"] = ges["course"].str.replace(
    r"\bwith\s*$", "", regex=True
).str.strip()

ges["course"].unique()

ges["course"] = ges["course"].str.replace(
    r"(science)(and)", r"\1 \2", regex=True
)

ges["course"] = ges["course"].str.replace(
    r"(and)(science)", r"\1 \2", regex=True
)

ges["course"] = ges["course"].str.replace(
    r"(information)(security)", r"\1 \2", regex=True
)

ges["course"] = ges["course"].str.replace(
    r"(computer)(science)", r"\1 \2", regex=True
)

ges["course"] = ges["course"].str.replace(
    r"(science)(and)", r"\1 \2", regex=True
)

ges["course"] = ges["course"].str.replace(
    r"(and)(science)", r"\1 \2", regex=True
)

ges["course"] = ges["course"].str.replace(
    r"(information)(security)", r"\1 \2", regex=True
)

ges["course"] = ges["course"].str.replace(
    r"(computer)(science)", r"\1 \2", regex=True
)
ges["course"] = ges["course"].str.replace(
    r"([a-z])\(", r"\1 (", regex=True
).str.replace(
    r"\)([a-z])", r") \1", regex=True
)

"""Now we can map the courses in ges to the courses in ieg"""

INTAKE_CATEGORIES = [
    "Medicine",
    "Dentistry",
    "Law",
    "Education",
    "Architecture & Built Environment",
    "Health Sciences",
    "Engineering",
    "Information Technology",
    "Sciences",
    "Arts & Social Sciences",
    "Business & Administration",
    "Accountancy",
    "Services",
    "Others"
]

def map_course(course):
    if pd.isna(course):
        return "Others"

    c = course.lower()

    # 1Ô∏è‚É£ Very specific, protected categories first
    if "medicine" in c:
        return "Medicine"
    if "dentistry" in c or "dental" in c:
        return "Dentistry"
    if "law" in c:
        return "Law"
    if "education" in c:
        return "Education"

    # 2Ô∏è‚É£ Built environment
    if any(k in c for k in ["architecture", "real estate", "building", "landscape"]):
        return "Architecture & Built Environment"

    # 3Ô∏è‚É£ Health
    if any(k in c for k in ["nursing", "physiotherapy", "radiography", "therapy", "health"]):
        return "Health Sciences"

    # 4Ô∏è‚É£ IT (must come BEFORE science)
    if any(k in c for k in ["computer", "computing", "information system", "data science", "information technology"]):
        return "Information Technology"

    # 5Ô∏è‚É£ Engineering
    if "engineering" in c:
        return "Engineering"

    # 6Ô∏è‚É£ Accountancy before Business
    if "accountancy" in c:
        return "Accountancy"

    # 7Ô∏è‚É£ Business / Admin
    if any(k in c for k in ["business", "management", "marketing", "finance"]):
        return "Business & Administration"

    # 8Ô∏è‚É£ Sciences (after health + IT)
    if any(k in c for k in ["science", "physics", "chemistry", "biology", "mathematics"]):
        return "Sciences"

    # 9Ô∏è‚É£ Arts & Social Sciences
    if any(k in c for k in ["arts", "history", "philosophy", "sociology", "psychology", "economics", "linguistics"]):
        return "Arts & Social Sciences"

    # üîü Services (hospitality, security, etc.)
    if any(k in c for k in ["hospitality", "culinary", "service", "tourism", "security"]):
        return "Services"

    return "Others"
ges["course_category"] = ges["course"].apply(map_course)

ges["course_category"].value_counts()

ges.loc[
    ges["course"].str.contains("science", na=False),
    ["course", "course_category"]
].head(15)

ges.loc[
    ges["course_category"] == "Others",
    "course"
].dropna().unique()

ges.head(3)

import pandas as pd
import re

# Example dataset
# ges = pd.read_csv("GraduateEmploymentSurvey_cleaned.csv")

# Regex pattern for missing / placeholder values
missing_pattern = re.compile(r'^\s*(na|n/a|none)?\s*$', re.IGNORECASE)
# Find problematic rows
school_na = ges['school'].apply(lambda x: bool(missing_pattern.match(str(x))))
course_na = ges['course'].apply(lambda x: bool(missing_pattern.match(str(x))))

print("Rows with missing/invalid school:", school_na.sum())
print("Rows with missing/invalid course:", course_na.sum())

# Optional: show the rows themselves
print(ges[school_na | course_na])
# If you want to drop them
ges = ges[~(school_na | course_na)]
# Drop rows where school is "na"
ges = ges[~school_na]

# Optional: confirm none remain
print("Rows with missing/invalid school:", ges['school'].apply(lambda x: bool(missing_pattern.match(str(x)))).sum())

#ges.to_csv('CleanedGraduateEmploymentSurvey.csv', index=False)

"""# Analysis 1:
## Graduate Salary Trends and Growth by Course Category (2014‚Äì2022)
##Objective

This analysis examines how the median monthly salaries of graduates evolve over time across different course categories in Singapore. Beyond observing overall salary trends, we also perform a drill-down analysis to explore variations within a selected course category. Finally, we analysed year-on-year (YoY) growth rates to understand changes in the pace of salary growth.

We begin by grouping the GES dataset by year and course category, computing the average median monthly salary and employment rate. This provides a high-level view of graduate outcomes across disciplines over time.
"""

ges_agg = (
    ges.groupby(["year", "course_category"], as_index=False)
       .agg(
           avg_median_salary=("gross_monthly_median", "mean"),
           avg_employment_rate=("employment_rate_overall", "mean")
       )
)

"""Next, we process the IEG to obtain the total number of graduates per course category per year. This allows us to later contextualise salary trends with graduate supply."""

ieg["course_category"] = ieg["course"].str.lower().apply(map_course)

ieg_agg = (
    ieg.groupby(["year", "course_category"], as_index=False)
       .agg(
           total_graduates=("graduates", "sum")
       )
)

"""The aggregated datasets are merged to form a unified analytical table containing salary outcomes, employment rates, and graduate counts for each course category and year."""

analysis_1 = pd.merge(
    ges_agg,
    ieg_agg,
    on=["year", "course_category"],
    how="inner"
)

analysis_1.head()

"""To support growth-rate analysis, the dataset is sorted chronologically within each course category. The year-on-year percentage change in median salary is then computed."""

analysis_1 = analysis_1.sort_values(["course_category", "year"])

analysis_1["salary_yoy_growth_pct"] = (
    analysis_1
    .groupby("course_category")["avg_median_salary"]
    .pct_change() * 100
)

"""This chart shows the absolute level of median monthly salaries across selected course categories from 2014 to 2022. It highlights long-term structural trends and relative differences in earning levels between disciplines."""

import matplotlib.pyplot as plt
import seaborn as sns
focus_categories = [
    "Engineering",
    "Information Technology",
    "Business & Administration",
    "Sciences",
    "Arts & Social Sciences"
]

trend_data = analysis_1[
    analysis_1["course_category"].isin(focus_categories)
]

plt.figure(figsize=(10, 6))
sns.lineplot(
    data=trend_data,
    x="year",
    y="avg_median_salary",
    hue="course_category",
    marker="o"
)

plt.title("Median Salary Trends by Course Category")
plt.xlabel("Year")
plt.ylabel("Median Monthly Salary ($)")
plt.legend(title="Course Category")
plt.tight_layout()
plt.show()

"""To support more detailed exploration, a reusable function is defined to perform course-level drill-down analysis within any selected course category. This enables finer-grained insights beyond category-level averages."""

def drilldown_salary_trends(df, course_category):
    filtered = df[df["course_category"] == course_category]

    course_trends = (
        filtered
        .groupby(["year", "course"], as_index=False)
        .agg(
            avg_median_salary=("gross_monthly_median", "mean")
        )
        .sort_values(["course", "year"])
    )

    course_trends["yoy_growth_pct"] = (
        course_trends
        .groupby("course")["avg_median_salary"]
        .pct_change() * 100
    )

    return course_trends

"""The drill-down function is applied to multiple course categories, demonstrating that the analysis logic is parameterised and reusable, which aligns with the Data Analytics as a Service (DAaaS) design."""

it_trends = drilldown_salary_trends(ges, "Information Technology")
eng_trends = drilldown_salary_trends(ges, "Engineering")
biz_trends = drilldown_salary_trends(ges, "Business & Administration")

"""As an example, we further zoom into the Information Technology category by selecting the top IT courses by average salary and visualising their salary trends over time. This highlights heterogeneity within a single discipline."""

it_data = ges[ges["course_category"] == "Information Technology"]
it_course_trends = (
    it_data
    .groupby(["year", "course"], as_index=False)
    .agg(
        avg_median_salary=("gross_monthly_median", "mean")
    )
)


top_it_courses = (
    it_course_trends
    .groupby("course")["avg_median_salary"]
    .mean()
    .sort_values(ascending=False)
    .head(7)
    .index
)

plot_data = it_course_trends[
    it_course_trends["course"].isin(top_it_courses)
]

sns.lineplot(
    data=plot_data,
    x="year",
    y="avg_median_salary",
    hue="course",
    marker="o"
)

"""Finally, the year-on-year growth chart highlights fluctuations in the pace of salary growth, even when overall salary levels show a consistent upward trend."""

plt.figure(figsize=(10, 6))
sns.lineplot(
    data=trend_data,
    x="year",
    y="salary_yoy_growth_pct",
    hue="course_category",
    marker="o"
)

plt.axhline(0, linestyle="--")
plt.title("Year-on-Year Median Salary Growth by Course Category")
plt.xlabel("Year")
plt.ylabel("YoY Growth (%)")
plt.legend(title="Course Category")
plt.tight_layout()
plt.show()

# def top_courses_by_salary(trends_df, top_n=5):
#     top_courses = (
#         trends_df
#         .groupby("course")["avg_median_salary"]
#         .mean()
#         .sort_values(ascending=False)
#         .head(top_n)
#         .index
#     )

#     return trends_df[trends_df["course"].isin(top_courses)]

import matplotlib.pyplot as plt
import seaborn as sns

# plt.figure(figsize=(10, 6))
# sns.scatterplot(
#     data=analysis_1,
#     x="total_graduates",
#     y="median_salary",
#     hue="course_category",
#     alpha=0.7
# )

# plt.title("Graduate Supply vs Median Salary by Course Category")
# plt.xlabel("Number of Graduates")
# plt.ylabel("Median Monthly Salary ($)")
# plt.legend(bbox_to_anchor=(1.05, 1), loc="upper left")
# plt.tight_layout()
# plt.show()



"""# Analysis 2
## Employment rate vs salary by course category
"""



"""#Analysis 3
#Trends over time
"""



# normalise = {
#     "laws": "law",
#     "laws (llb)": "law",
#     "laws (l.l.b)": "law",
#     "medicine and surgery": "medicine",
#     "medicine and bachelor of surgery": "medicine",
#     "physics / applied physics": "physics and applied physics"
# }

# ges["course_cleaned"] = ges["course_cleaned"].replace(normalise)

# ges["course_cleaned"] = ges["course_cleaned"].replace("", pd.NA)

# ges["course_cleaned"] = ges["course_cleaned"].str.replace(
#     r"\d+$", "", regex=True
# )

# ges["course_cleaned"] = ges["course_cleaned"].str.replace(
#     r"([a-z])\(", r"\1 (", regex=True
# )

# ges["course_cleaned"] = ges["course_cleaned"].str.replace(
#     r"(resource)(management)", r"\1 \2", regex=True
# )

# ges["course_cleaned"] = ges["course_cleaned"].str.replace(
#     r"([a-z])([A-Z])", r"\1 \2", regex=True
# )

# fixes = {
#     "computationalbiology": "computational biology",
#     "pharmaceuticalscience": "pharmaceutical science",
#     "materialsscience": "materials science",
#     "engineeringscience": "engineering science",
#     "informationsecurity": "information security"
# }

# ges["course_cleaned"] = ges["course_cleaned"].replace(fixes, regex=True)

# ges = ges[~ges["course_cleaned"].str.endswith(" with", na=False)]

# ges["course_cleaned"] = ges["course_cleaned"].str.strip()
# ges = ges[~ges["course_cleaned"].str.endswith(" with", na=False)]

# ges["course_cleaned"].unique()#[140:]